<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Falling Blocks Heart</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; cursor: pointer; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>
<body>
<script>
  // Setup scene
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  camera.position.z = 60;

  // Group for heart blocks
  const heartGroup = new THREE.Group();
  scene.add(heartGroup);

  // Generate heart shape points (2D)
  const heartShape = [];
  for (let t = 0; t < Math.PI * 2; t += 0.15) {
    const x = 16 * Math.pow(Math.sin(t), 3);
    const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
    heartShape.push({x, y});
  }

  // Function to drop blocks and form heart
  function dropBlocks() {
    // Clear previous blocks
    while (heartGroup.children.length > 0) {
      heartGroup.remove(heartGroup.children[0]);
    }

    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshBasicMaterial({ color: 0xff3366 });

    heartShape.forEach((p, i) => {
      const block = new THREE.Mesh(geometry, material);

      // start from random X and Y above screen
      block.position.set((Math.random() - 0.5) * 80, 40 + Math.random() * 20, 0);

      heartGroup.add(block);

      // animate block falling into heart position
      gsap.to(block.position, {
        x: p.x,
        y: p.y,
        z: 0,
        duration: 2,
        delay: i * 0.05,
        ease: "bounce.out"
      });
    });
  }

  // Click event
  window.addEventListener("click", dropBlocks);

  // Animation loop
  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }
  animate();

  // Handle resize
  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
